Status: #

Class: [[software engineering]]

Subject/Topics: #Exam

Date: 2024-08-02

Teacher:
___

Notes:
### Week#1 - Class Overview

  

#### Topics Covered:

- Course outline and schedule

- Course requirements and evaluation criteria

- Overview of Software Engineering

  

#### What is Software Engineering?

Software engineering is a field of computer science focused on the analysis, design, development, testing, implementation, and maintenance of software programs. It involves applying engineering principles and programming languages to create software solutions. Careers in software engineering can range from software developers and game developers to roles in network control systems and commercial applications. As technology advances, the demand for software developers grows, with opportunities in various sectors including healthcare, government, and businesses of all sizes.

  

#### Employment Options in Software Engineering:

Software engineering offers diverse career paths, including:

- **Applications Developers:** Create software for specific clients or for public sale, including games and databases.

- **Systems Developers:** Design operating systems and user interfaces for various devices, such as phones and cars.

  

Other roles include:

- Programmer

- Systems Analyst

- Database Administrator

- Project Leader

- Quality Assurance Analyst

- Mobile Developer

  

#### Job Responsibilities:

Typical duties of software engineers include:

- Writing and testing code

- Maintaining system documentation

- Managing software applications or systems

- Distributing updates

- Testing and optimizing software

- Consulting with stakeholders and other experts

  

#### Required Skills:

Software engineers need a combination of technical and soft skills, including:

- Proficiency in programming languages (Java, Python, C++)

- Knowledge of database architecture and operating systems

- Understanding of Agile and Scrum methodologies

- Skills in problem-solving, attention to detail, teamwork, and communication

  

#### Future of Software Engineering:

The field is expected to grow significantly, with a 22% increase in employment for software developers, testers, and quality assurance analysts by 2035, reflecting the increasing reliance on technology and the expansion of the internet of things.

  

  

### Week#2 - Introduction to Software Engineering

  

#### Topics Covered:

- Meaning of "software engineering" in professional software development

- Software engineering ethics and moral dilemmas in software development

- Case studies: Four examples provided

  

#### Software Engineering Overview

- **Economic Impact:** Software significantly impacts the economy of developed countries and is increasingly used in all business activities.

- **Professional Development:** Involves methods, theories, and tools for developing software professionally, representing a significant portion of a country's Gross National Product.

  

#### Software Costs

- Software costs often drive computer system costs, with maintenance often being more expensive than development.

- Reasonable software development requires software engineering to manage these costs.

  

#### Reasons for Software Project Failures

1. **Lack of Software Engineering Techniques:** Companies often develop software without proper engineering techniques, leading to higher costs and less reliable products.

2. **Increasing System Complexity:** Modern methods help build scalable and complex systems, but rapid changes in demands can lead to challenges in meeting these requirements.

  

#### Types of Software

1. **Generic Products:** Stand-alone systems available to anyone (e.g., PC software, CAD tools).

2. **Custom Products:** Software developed specifically for a client's requirements (e.g., bug tracking systems, custom e-commerce solutions).

  

#### Characteristics of Good Software

- **Efficiency:** Optimizes resources like memory and processing power.

- **Maintainability:** Easily adaptable to changing user needs.

- **Dependability and Security:** Reliable and safe, preventing harm in case of failure and protecting against malicious access.

- **Acceptability:** Practical, compatible, and user-friendly for intended users.

  

#### Importance of Software Engineering

- Essential for developing reliable and cost-effective software systems quickly.

- Most system costs are associated with maintaining and evolving the software after deployment.

  

#### Software Process Activities

1. **Software Specification:** Defining the software and its constraints.

2. **Software Development:** Designing and coding the software.

3. **Software Validation:** Ensuring the software meets user requirements.

4. **Software Evolution:** Modifying the software to meet changing needs.

  

#### General Factors Affecting Software

- **Heterogeneity:** Systems need to function across diverse devices.

- **Business and Social Change:** Rapid changes require adaptable software.

- **Security and Trust:** Essential for widespread reliance on software.

- **Scale:** Systems range from small embedded systems to large-scale cloud applications.

  

#### Software Engineering Distinctiveness

- Different types of software systems require specific methodologies and tools, depending on the application and development team.

  

#### Application Types

- **Stand-alone applications, Interactive transaction-based systems, Embedded control systems, Batch processing systems, Entertainment software, Modelling and simulation, Data collection systems, Systems of systems.**

  

#### Basic Principles of Software Engineering

- A controlled and organized development process is crucial.

- Dependability and performance are key for all systems.

- Understanding and managing requirements is essential.

- Reusing existing software components can save time and resources.

  

#### Software Engineering for Mobile and Internet

- **Web Services and Cloud Computing:** Enable remote execution of applications and on-demand services.

- **Internet-based Software Engineering:** Involves agile development, software reuse, service-oriented systems, and rich interfaces.

  

#### Ethics in Software Engineering

- **Professional Responsibilities:** Software engineers must act ethically, respecting confidentiality, intellectual property rights, and avoiding computer misuse.

- **ACM/IEEE Code of Ethics:** A set of principles guiding professional behavior in software engineering.

  

#### Case Studies

1. **Insulin Pump:** A safety-critical device controlling insulin levels.

2. **Mental Health Patient Information System (Mentcare):** A system managing patient data and treatment information.

3. **Climate Station:** A system for collecting and managing weather data.

4. **Digital Classroom (iLearn):** A customizable framework for educational tools and resources.

  

#### Summary

- Software engineering encompasses all aspects of software development, focusing on key attributes like maintainability, dependability, security, efficiency, and acceptability.

- Understanding core principles is beneficial for all system types, with specialized methods for different applications.

- Software engineers have ethical responsibilities to society and their profession, extending beyond technical considerations.

  

**Week 3: Software Development Processes**

  

### **1. Models for the Software Development Process**

The software development process involves a series of steps designed to enhance a software system, including specification, design and implementation, validation, and evolution. Various methodologies exist, often incorporating aspects of both plan-driven and agile methods.

  

#### **Software Process Models:**

1. **Waterfall Model:** A linear and sequential approach where each phase must be completed before the next begins. It includes stages like preliminary investigation, project planning, system analysis, design, development, testing, and maintenance. 

2. **Incremental Development:** The project is divided into smaller parts, with each part being developed and delivered incrementally. It allows for early delivery of functional software and easier incorporation of changes.

3. **Integration and Configuration:** Focuses on reusing existing software modules (COTS) and integrating them into the system. This approach reduces development time and cost but may require compromises in functionality.

  

### **2. Activities in the Software Development Process**

The main activities include specification, system analysis, software design, system development, system validation, and system evolution.

  

#### **Key Process Activities:**

- **Software Specification:** Determining the required services and constraints.

- **System Analysis:** Understanding and modeling the existing system.

- **Software Design:** Creating a detailed specification for the system's components, interfaces, and architecture.

- **System Development:** Converting the design into executable software, involving coding and configuration.

- **System Validation:** Ensuring the system meets the requirements through testing.

- **System Evolution:** Modifying the software to adapt to new requirements and improve functionality.

  

### **3. Managing Change**

Software systems must evolve due to changing business needs, new technologies, or platform changes. Managing change involves anticipating and accommodating changes efficiently, often through prototyping and incremental delivery.

  

#### **Key Concepts:**

- **Change Anticipation:** Planning for potential changes early in the development process.

- **Change Tolerance:** Structuring the process to allow for changes with minimal cost and disruption.

  

### **4. Improving the Software Development Process**

Process improvement aims to enhance product quality, reduce costs, or accelerate development.

  

#### **Methods for Improvement:**

- **Method Maturity Approach:** Focuses on improving system and task management and implementing best practices in software engineering.

- **Agile Methodology:** Emphasizes iterative development, quick delivery, and flexibility to accommodate changing customer requirements.

  

#### **Process Improvement Activities:**

- **Process Measurement:** Collecting data to evaluate the effectiveness of process improvements.

- **Process Analysis:** Identifying bottlenecks and weaknesses in the process.

- **Process Change:** Implementing changes to address identified issues.

  

### **Summary**

The software development process encompasses a range of activities and methodologies, including the waterfall model, incremental development, and reuse-oriented approaches. Key activities include specification, design, development, validation, and evolution. Managing and improving these processes involves anticipating changes, adopting agile practices, and continuously measuring and refining methods to enhance efficiency and product quality.

  

### Week#4 - Agile Software Development

  

#### Principle of Agile Methods for Software Development

Agile methods prioritize flexibility and collaboration, focusing on iterative development, continuous customer involvement, and responsiveness to change. Key principles include:

  

- **Progressive Delivery**: Customers define criteria for each increment, allowing the program to evolve over time.

- **Customer Participation**: Active involvement of customers in all stages of development to provide feedback and prioritize requirements.

- **Accept Change**: Systems are designed to accommodate changes in requirements.

- **Not a Process, People**: Emphasizes the skills and contributions of the development team over rigid processes.

- **Ensure Simplicity**: Focuses on simplicity in both the system and the development process.

  

#### Techniques of Agile Development

Agile techniques include Extreme Programming (XP) and Scrum, both of which emphasize frequent iterations, minimal documentation, and rapid delivery of functional software.

  

**Extreme Programming (XP)**:

- **Tiny Releases**: Start with minimal functionality and incrementally add features.

- **Continual Preparation**: Use story cards to break down and prioritize tasks.

- **Simple Structure**: Minimal upfront design, focusing on current needs.

- **Test-First Development**: Write tests before implementing features.

- **Refactoring**: Continuously improve code for simplicity and readability.

- **Continuous Integration**: Integrate changes frequently, ensuring all tests pass.

- **Pair Programming**: Developers work in pairs to enhance code quality and share knowledge.

- **Group Ownership**: All developers are responsible for the codebase.

- **Maintainable Speed**: Avoid excessive overtime to maintain quality.

- **On-Site Client**: Customer representatives are part of the development team.

  

**Scrum**:

- **Sprint Cycles**: Time-boxed iterations (2-4 weeks) focused on delivering increments of the product.

- **Daily Scrums**: Short daily meetings to review progress and plan the day's work.

- **Product Owner**: Defines and prioritizes the product backlog.

- **Scrum Master**: Facilitates the Scrum process and removes impediments.

- **Product Backlog**: A prioritized list of tasks and features.

  

#### Project Management in Agile

Agile project management focuses on delivering increments of the product, with continuous feedback and adaptation. Scrum is a popular framework, emphasizing iterative progress through sprints, collaboration, and flexibility.

  

**Terms in Scrum**:

- **Development Team**: A self-organizing group responsible for creating the software.

- **Potentially Shippable Product Increment**: The output of each sprint, aiming to be ready for release.

- **Product Owner**: Manages the backlog and represents stakeholders.

- **Scrum**: Daily meeting for planning and reviewing progress.

- **Scrum Master**: Ensures adherence to Scrum practices.

- **Sprint**: An iteration of work, typically lasting 2-4 weeks.

- **Velocity**: A measure of the amount of work a team can complete in a sprint.

  

#### Scaling Agile Methods

Scaling agile involves adapting agile practices to larger, more complex projects and organizations. This includes:

  

- **Scaling Up**: Applying agile techniques to large systems that cannot be built by a small team.

- **Scaling Out**: Extending agile principles across a large organization.

  

#### Rapid Software Development

Rapid development focuses on quick delivery of software systems, responding to changing business needs. It contrasts with plan-driven approaches by prioritizing flexibility and adaptability over detailed upfront planning.

  

#### Agile and Plan-Driven Development

While agile emphasizes flexibility and customer collaboration, plan-driven development involves detailed planning and documentation. In practice, many organizations use a combination of both approaches to balance flexibility with the need for structure and documentation.

  

#### Challenges and Considerations

- **Contractual Issues**: Agile's informality can conflict with traditional contract requirements.

- **Maintenance**: Agile methods may struggle with long-term maintenance due to limited documentation.

- **Organizational Culture**: Agile's flexibility may clash with traditional, highly structured environments.

  

### Summary

Agile methods, such as XP and Scrum, emphasize iterative development, customer involvement, and minimal documentation. They are well-suited for projects requiring flexibility and quick adaptation but may face challenges in large-scale systems and environments with rigid contractual or organizational structures.

  

**Week #5 - Requirements Engineering**

  

### Topics

1. **Requirement Engineering Concepts**

2. **Functional and Non-functional Requirements**

3. **Methodologies for Requirements Engineering**

4. **Requirements Change Management**

  

### Requirements Engineering

Requirements engineering involves determining the features and constraints that a consumer needs from a system. It includes the system requirements, which describe system services and limitations.

  

### What is a Requirement?

A requirement can range from a complex mathematical specification to a high-level description of a system's scope. Requirements may serve two purposes:

- As the basis for a contract bid, requiring adaptability.

- As the basis for the actual contract, requiring precise specifications.

  

#### Types of Requirements

1. **User Requirements:** Descriptions of system strengths and weaknesses in normal language, targeted at users/customers.

2. **System Requirements:** A detailed guide specifying system features, services, and constraints, often used in contracts between clients and contractors.

  

### System Stakeholders

Anyone affected by the system, including:

- System managers

- Business experts

- End users

- System operators

- External parties (technical and non-technical)

  

### Agile Methods and Requirements

Agile methods contend that detailed system requirements can become outdated quickly. They use incremental requirements engineering and user stories, which is practical for business systems but can be challenging for critical systems or those developed by multiple teams.

  

### Functional and Non-functional Requirements

- **Functional Requirements:** What the system should do, how it should react to inputs, and specific behaviors.

- **Non-functional Requirements:** Constraints on system functions or features, including performance, security, and usability.

  

### Functional Requirements Example (Mentcare System)

- Access to appointment listings across all clinics.

- Daily list of patients with appointments.

- Unique identification for employees using an 8-digit number.

  

### Non-functional Requirements

These specify system characteristics like reliability, response time, and storage. They can impact the system architecture and may include product specifications, organizational needs, and external conditions.

  

### Requirements Engineering Processes

The processes typically include:

- **Requirements Elicitation:** Understanding the system's domain, services, and operational constraints.

- **Requirements Analysis:** Analyzing gathered requirements.

- **Requirements Validation:** Ensuring the requirements accurately reflect the customer's needs.

- **Requirements Management:** Managing changes to requirements.

  

### Requirements Elicitation Techniques

- **Interviewing:** Formal or informal discussions with stakeholders.

- **Ethnography:** Observing how people actually work.

- **Stories and Scenarios:** Real-world examples showing system usage.

  

### Requirements Specification

Documenting user and system requirements clearly. Techniques include:

- **Natural Language:** Clear, structured language for understanding.

- **Structured Language:** Limited freedom in writing requirements for uniformity.

- **Visual Notations (USE-CASE):** High-level graphical representations supplemented by detailed descriptions.

  

### Requirements Validation

Ensuring that requirements define the desired system accurately. Techniques include:

- **Requirements Reviews:** Systematic examination.

- **Prototyping:** Using system models for examination.

- **Test Case Generation:** Creating tests for verifying requirements.

  

### Requirements Change Management

Handling changes in requirements due to new business needs, hardware, or regulations. It involves:

- **Requirements Identification:** Unique identification for traceability.

- **Change Management Process:** Evaluating the impact and cost of changes.

- **Requirements Tractability Policies:** Maintaining relationships between requirements and the system architecture.

  

### Summary

- Requirements describe what a system should do and the constraints on its operation.

- The requirements engineering process is iterative, involving elicitation, specification, validation, and management.

- Both functional and non-functional requirements are crucial, with the latter often influencing the system's architecture.

- Effective requirements management involves tracking changes and maintaining clear documentation.

  

**Week 6 - System Modeling**

  

**Topics:**

- System modeling for software engineering

- UML diagrams

- Model-driven engineering

  

### System Modeling

System modeling involves creating abstract representations of a system from different perspectives. It often uses notations from the Unified Modeling Language (UML) to visualize and communicate how a system functions, both to customers and analysts.

  

### Current and Future System Models

- **Current System Models:** Used during requirements engineering to understand the existing system, analyze its strengths and weaknesses, and form the basis for new system requirements.

- **Future System Models:** Help stakeholders understand anticipated needs and assist engineers in discussing design concepts before implementation. In model-driven engineering, these models can lead to full or partial system implementation.

  

### System Viewpoints

1. **External Perspective:** Focuses on the system's context or environment.

2. **Interaction Perspective:** Models how the system interacts with its environment and components.

3. **Structural Perspective:** Shows how the system is organized internally.

4. **Behavioral Perspective:** Models the system's dynamic behavior in response to events.

  

### UML Diagram Types

- **Activity Diagrams:** Describe the steps in a process or data processing.

- **Use Case Diagrams:** Show interactions between the system and external entities (users or other systems).

- **Sequence Diagrams:** Detail the interactions between actors and the system or between system components, focusing on the sequence of data exchange.

- **Class Diagrams:** Depict the system's object classes and their relationships, including specific data attributes.

- **State Diagrams:** Illustrate how the system responds to internal and external events.

  

### Using Graphical Models

Models are tools for conversation and need not be complete or fully accurate. They should represent the system appropriately to facilitate discussions about current and future systems.

  

### Context Models

- **System Boundaries:** Define what is inside and outside the system, showing interacting systems and dependencies. These boundaries significantly impact system requirements and can be influenced by organizational and social factors.

  

### Process Perspective

Context models do not show how a system is used in its environment; instead, they show other systems in that environment. Process models illustrate how the system integrates into broader business processes, often using UML activity diagrams.

  

### Interaction Models

Modeling interactions is crucial for understanding user needs and system dependencies. Use case and sequence diagrams are used to identify and detail these interactions.

  

### USE CASE Modeling

- Originally created for requirements elicitation, use cases now form part of the UML. Each use case describes a particular function involving interaction with external systems or actors, which can be people or other systems.

  

### Sequence Diagrams

These diagrams show the sequence of interactions in a system, detailing how actors and objects interact.

  

### Structural Models

Structural models depict the system's components and their relationships, showing both static (design-time) and dynamic (runtime) organization.

  

### Class Diagrams

Class diagrams represent the system's data classes and their interrelations, essential for building object-oriented systems.

  

### Generalization

Generalization helps manage complexity by grouping similar objects into more generic classes, allowing for inheritance of properties and methods.

  

### Behavioral Models

Behavioral models describe the system's dynamic behavior in response to data or events. They can be data-driven, focusing on how data is processed, or event-driven, showing responses to specific events.

  

### Model-Driven Engineering (MDE)

MDE focuses on creating models from which software applications are automatically generated. It allows for higher levels of abstraction and platform independence but faces challenges like tool support and the relevance of abstractions for implementation.

  

### Summary

- **Contextual Models:** Show how a system relates to other systems and processes.

- **System Models:** Use different types of diagrams to represent system context, interactions, structure, and behavior.

- **MDE:** Proposes a model-centric approach to software development, with models potentially generating executable code.

  

This overview covers the essential aspects of system modeling, emphasizing the use of UML diagrams and the model-driven engineering approach in software development.

  

### Week #7 - Process and Data Modeling

  

#### Topics

1. **Examining Data Flow Diagrams (DFDs):** Understanding logical modeling of processes.

2. **Guidelines and Regulations for Drawing DFDs:** Rules and best practices.

3. **Entity-Relationship (E-R) Diagrams:** Visual representation of data and relationships.

4. **Conceptual Data Modeling:** Role in information system development.

5. **Using ERD with DFD:** Integrating ERD in the context of data flow analysis.

  

---

  

### Process Modeling

**Process modeling** involves graphically displaying the data receiving, storing, and distribution procedures of an information system. It captures data movements between external entities, internal processes, and data repositories using Data Flow Diagrams (DFDs).

  

#### Data Flow Diagram (DFD)

A DFD visually represents the flow of data within an organization’s information system, illustrating how data is processed from inputs to storage and report generation. It serves as a tool for communication between system users and analysts by using symbols to depict processes, data stores, external entities, and data flows.

  

**Why Use DFDs?**

- Specify the logical flow of information.

- Identify system requirements and physical system development needs.

- Use simple notation for easy understanding.

- Provide a scalable overview from broad to detailed system views.

  

**DFD Symbols:**

1. **Process:** Represents activities transforming data inputs into outputs (e.g., "Order Processing").

2. **Data Store:** Depicts places where data is stored for future use.

3. **External Entities:** Elements outside the system providing inputs or receiving outputs.

4. **Data Flow:** Shows the movement of data between elements in the system.

  

---

  

### Levels of DFDs

- **Context Diagram (Level 0):** Provides a system overview with a single process node.

- **Level 1 DFD:** Breaks down the main system process into subprocesses.

- **Level 2 and Beyond:** Further decomposes processes for more detailed understanding.

  

**Rules and Guidelines for DFDs:**

- Each item must have a unique name.

- Processes must have different inputs and outputs.

- Use noun phrases for Data Stores and External Entities, and verb phrases for Processes.

- Data must flow through processes, not directly between stores or sources/sinks.

  

#### Techniques for Top-Down Decomposition

- **Levelling:** Involves creating increasingly detailed DFDs.

- **DFD Balancing:** Ensures consistency between the levels of DFDs.

  

**DFD Drawing Recommendations:**

- Ensure completeness and consistency.

- Exclude timing details.

- Prepare for iterative development.

- Stop decomposition when reaching the lowest logical level.

  

---

  

### Data Modeling

**Entity-Relationship Diagrams (ERD)** visually represent data relationships within an information system. They help in database architecture and understanding business rules.

  

**Components of ERD:**

1. **Entities:** Represent tables or objects (e.g., Student, Product).

2. **Attributes:** Properties of entities (e.g., Student ID, Product Name).

3. **Relationships:** Connections between entities (e.g., students enrolling in courses).

  

**Types of Relationships:**

- **Unary:** Self-relationship within the same entity.

- **Binary:** Between two different entities.

- **Ternary:** Involving three entities.

  

**Cardinality:** Indicates the numerical relationship between entities (one-to-many, many-to-many).

  

**Creating an ERD:**

- Define the scope and purpose.

- Identify key entities and their attributes.

- Establish relationships and apply normalization techniques.

  

---

  

### Integrating ERD with DFD

- **ERD and DFD** can be complementary. While DFDs focus on data flow, ERDs detail data relationships and structures.

- Entities in ERDs correspond to data stores in DFDs, illustrating both data usage and flow within the system.

  

This comprehensive overview serves as a foundation for understanding how to effectively model processes and data within an information system, ensuring clarity, consistency, and accuracy in system design.